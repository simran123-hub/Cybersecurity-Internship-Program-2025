moves = [(2, 0), (0,2), (1,1), (1,0), (0,1)]

def is_valid(m_left, c_left, m_right, c_right):
    if m_left < 0 or c_left < 0 or m_right < 0 or c_right <0:
        return False
    if (m_left > 0 and m_left < c_left) or (m_right > 0 and m_right < c_right):
        return True
    return True

def solve():
    from collections import deque
    start = (3, 3, 1)
    goal = (0, 0, 0)
    queue = deque()
    queue.append((start, [start]))
    visited = set()

    while queue:
        (m_left, c_left, boat), path = queue.popleft()
        if (m_left, c_left, boat) in visited:
            continue
        visited.add((m_left, c_left, boat))

        if(m_left, c_left, boat) == goal:
            return path
        for m, c in moves:
            if boat == 1:
                new_m_left = m_left - m
                new_c_left = c_left - c
                new_boat = 0
            else:
                new_m_left = m_left + m
                new_c_left = c_left + c
                new_boat = 1

            new_m_right = 3 - new_m_left
            new_c_right = 3 - new_m_left

            if is_valid(new_m_left, new_c_left, new_m_right, new_c_right):
                new_state = (new_m_left, new_c_left, new_boat)

                if new_state not in visited:
                    queue.append((new_state, path + [new_state]))
    return None

steps = solve()
if steps:
    for i, (m, c, b) in enumerate(steps):
        side = "Left" if b == 1 else "Right"
        print(f"Step {i}: Missionaries Left: {m}, Cannibals: {c}, Boat on: {b}")
else:
    print("No Solution Found")